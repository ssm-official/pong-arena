<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CryptoPong — Practice Mode</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            arena: { bg: '#0a0a1a', card: '#111128', accent: '#7c3aed', glow: '#a855f7' }
          }
        }
      }
    };
  </script>
  <style>
    body { background: #0a0a1a; font-family: 'Segoe UI', system-ui, sans-serif; }
    .glow-border { box-shadow: 0 0 15px rgba(168, 85, 247, 0.3); }
    #game-canvas { background: #0f0f2a; border: 1px solid #2d2d5e; border-radius: 8px; }
    @keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 10px rgba(168, 85, 247, 0.4); } 50% { box-shadow: 0 0 25px rgba(168, 85, 247, 0.8); } }
    .diff-btn:hover { transform: translateY(-2px); transition: transform 0.2s; }
    .diff-btn.selected { ring: 2; }
  </style>
</head>
<body class="text-gray-100 min-h-screen">

  <!-- NAV BAR -->
  <nav class="bg-arena-card border-b border-purple-900/30 px-6 py-3 flex items-center justify-between">
    <div class="flex items-center gap-3">
      <a href="/" class="text-2xl font-bold bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent">CRYPTOPONG</a>
      <span class="text-xs text-gray-500 bg-gray-800 px-2 py-0.5 rounded">PRACTICE</span>
    </div>
    <a href="/" class="text-sm text-gray-400 hover:text-white transition">Back to CryptoPong</a>
  </nav>

  <!-- MAIN CONTENT -->
  <div class="max-w-5xl mx-auto px-4 py-6">

    <!-- Difficulty Selection Screen -->
    <div id="view-difficulty" class="text-center py-10">
      <h1 class="text-3xl font-bold mb-2 bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent">
        Practice Mode
      </h1>
      <p class="text-gray-400 mb-8 max-w-md mx-auto">
        Sharpen your skills against a bot. No wallet or stakes required.
      </p>
      <h2 class="text-xl font-bold mb-4">Choose Bot Difficulty</h2>
      <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 max-w-2xl mx-auto mb-6">
        <button onclick="selectDifficulty('easy')"
          class="diff-btn bg-arena-card border border-green-800 hover:border-green-500 rounded-xl p-6 text-center transition">
          <div class="text-green-400 text-2xl font-bold mb-1">Easy</div>
          <div class="text-gray-400 text-sm">Slow reactions, makes mistakes.</div>
          <div class="text-gray-500 text-xs mt-2">Great for beginners</div>
        </button>
        <button onclick="selectDifficulty('medium')"
          class="diff-btn bg-arena-card border border-yellow-800 hover:border-yellow-500 rounded-xl p-6 text-center transition">
          <div class="text-yellow-400 text-2xl font-bold mb-1">Medium</div>
          <div class="text-gray-400 text-sm">Predicts ball trajectory.</div>
          <div class="text-gray-500 text-xs mt-2">A solid challenge</div>
        </button>
        <button onclick="selectDifficulty('hard')"
          class="diff-btn bg-arena-card border border-red-800 hover:border-red-500 rounded-xl p-6 text-center transition">
          <div class="text-red-400 text-2xl font-bold mb-1">Hard</div>
          <div class="text-gray-400 text-sm">Full prediction, almost never misses.</div>
          <div class="text-gray-500 text-xs mt-2">Only for the brave</div>
        </button>
      </div>
      <p class="text-gray-600 text-xs">Controls: W/S or Arrow Up/Down. First to 5 wins.</p>
    </div>

    <!-- Game View -->
    <div id="view-game" class="hidden">
      <div class="flex justify-between items-center mb-2 px-2">
        <div class="text-sm"><span class="text-purple-400 font-bold">You</span> (Player)</div>
        <div class="text-2xl font-bold">
          <span id="score-player">0</span> - <span id="score-bot">0</span>
        </div>
        <div class="text-sm"><span id="bot-difficulty-label" class="text-gray-400 font-bold"></span> (Bot)</div>
      </div>
      <canvas id="game-canvas" width="800" height="600" class="mx-auto block"></canvas>
      <p class="text-center text-gray-500 text-xs mt-2">Controls: W/S or Arrow Keys | First to 5 wins</p>
    </div>

    <!-- Game Over Screen -->
    <div id="view-gameover" class="hidden text-center py-10">
      <div class="bg-arena-card rounded-xl px-8 py-8 max-w-md mx-auto glow-border">
        <h3 id="gameover-title" class="text-3xl font-bold mb-3"></h3>
        <p id="gameover-score" class="text-gray-400 text-lg mb-6"></p>
        <div class="flex flex-col sm:flex-row gap-3 justify-center">
          <button onclick="playAgain()"
            class="bg-purple-600 hover:bg-purple-700 px-6 py-2 rounded-lg font-medium transition">
            Play Again
          </button>
          <button onclick="changeDifficulty()"
            class="bg-gray-700 hover:bg-gray-600 px-6 py-2 rounded-lg font-medium transition">
            Change Difficulty
          </button>
        </div>
        <a href="/" class="inline-block mt-4 text-sm text-gray-400 hover:text-white transition">Back to CryptoPong</a>
      </div>
    </div>

  </div>

  <!-- ============ SHARED PHYSICS ============ -->
  <script src="/js/pong-sim.js?v=34"></script>

  <!-- ============ INLINE GAME SCRIPT ============ -->
  <script>
  (function() {
    'use strict';

    // =============================================
    // CONSTANTS — from PongSim (shared module)
    // =============================================
    const CANVAS_W = PongSim.CANVAS_W;
    const CANVAS_H = PongSim.CANVAS_H;
    const PADDLE_W = PongSim.PADDLE_W;
    const PADDLE_H = PongSim.PADDLE_H;
    const PADDLE_SPEED = PongSim.PADDLE_SPEED;
    const BALL_SIZE = PongSim.BALL_SIZE;
    const WIN_SCORE = PongSim.WIN_SCORE;
    const P1_X = PongSim.P1_X;
    const P2_X = PongSim.P2_LEFT; // left edge of paddle 2

    const PHYSICS_DT = 1000 / 60; // fixed timestep: 60 steps/sec

    // --- Sound Effects ---
    let practiceAudioCtx = null;
    function getPracticeAudio() {
      if (!practiceAudioCtx) practiceAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return practiceAudioCtx;
    }
    function playPracticeSound(type) {
      try {
        const ctx = getPracticeAudio();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        if (type === 'paddle') {
          osc.frequency.value = 440; osc.type = 'square';
          gain.gain.value = 0.1;
          gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);
          osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.08);
        } else if (type === 'wall') {
          osc.frequency.value = 300; osc.type = 'triangle';
          gain.gain.value = 0.06;
          gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.06);
          osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.06);
        } else if (type === 'score') {
          osc.frequency.value = 220; osc.type = 'sawtooth';
          gain.gain.value = 0.12;
          gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
          osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.3);
        }
      } catch (e) {}
    }

    // =============================================
    // STATE
    // =============================================
    let canvas, ctx;
    let currentDifficulty = null;
    let gameRunning = false;
    let animFrameId = null;
    let lastTimestamp = 0;
    let accumulator = 0;

    // Simulation state (PongSim-managed)
    let simState = null;

    // Local score tracking (for display)
    let score = { player: 0, bot: 0 };
    let isPaused = false;
    let gameStatus = 'idle'; // 'idle', 'countdown', 'playing', 'finished'
    let countdownValue = 3;
    let countdownTimer = null;

    // Input
    const keys = {};
    let playerInput = 'stop';

    // Skin support
    const SKIN_DRAW_W = 60;
    const SKIN_DRAW_H = 200;
    let playerSkin = null;
    let playerSkinImage = null;

    // Bot AI state
    let botTargetY = CANVAS_H / 2;
    let botLastUpdateTime = 0;
    let botIntentionalMiss = false;

    // =============================================
    // LOAD EQUIPPED SKIN (if logged in)
    // =============================================
    (async function loadEquippedSkin() {
      try {
        const session = JSON.parse(localStorage.getItem('pong_session') || 'null');
        if (!session || !session.token) return;
        const res = await fetch('/api/profile', {
          headers: { 'Authorization': 'Bearer ' + session.token }
        });
        if (!res.ok) return;
        const data = await res.json();
        const equippedId = data.user && data.user.equippedSkin;
        if (!equippedId || equippedId === 'default') return;
        const shopRes = await fetch('/api/shop', {
          headers: { 'Authorization': 'Bearer ' + session.token }
        });
        if (!shopRes.ok) return;
        const shopData = await shopRes.json();
        const skin = (shopData.inventory || []).find(s => s.skinId === equippedId);
        if (!skin) return;
        playerSkin = skin;
        if (skin.type === 'image' && skin.imageUrl) {
          const img = new Image();
          img.src = skin.imageUrl;
          img.onload = () => { playerSkinImage = img; };
        }
      } catch (e) {
        // Silent fail — just use default purple
      }
    })();

    // =============================================
    // VIEW MANAGEMENT
    // =============================================
    function showView(viewId) {
      document.getElementById('view-difficulty').classList.add('hidden');
      document.getElementById('view-game').classList.add('hidden');
      document.getElementById('view-gameover').classList.add('hidden');
      document.getElementById(viewId).classList.remove('hidden');
    }

    // =============================================
    // DIFFICULTY SELECTION
    // =============================================
    window.selectDifficulty = function(diff) {
      currentDifficulty = diff;
      const labels = { easy: 'Easy', medium: 'Medium', hard: 'Hard' };
      document.getElementById('bot-difficulty-label').textContent = labels[diff];
      showView('view-game');
      startGame();
    };

    window.playAgain = function() {
      showView('view-game');
      startGame();
    };

    window.changeDifficulty = function() {
      stopGame();
      showView('view-difficulty');
    };

    // =============================================
    // GAME LIFECYCLE
    // =============================================
    function startGame() {
      canvas = document.getElementById('game-canvas');
      ctx = canvas.getContext('2d');

      // Create fresh simulation state via PongSim
      simState = PongSim.createState();

      // Reset local tracking
      score = { player: 0, bot: 0 };
      isPaused = false;
      gameStatus = 'countdown';
      countdownValue = 3;
      accumulator = 0;
      lastTimestamp = 0;
      botTargetY = CANVAS_H / 2;
      botLastUpdateTime = 0;
      botIntentionalMiss = false;

      updateScoreDisplay();
      setupInput();
      startCountdown();
    }

    function stopGame() {
      gameRunning = false;
      gameStatus = 'idle';
      if (animFrameId) {
        cancelAnimationFrame(animFrameId);
        animFrameId = null;
      }
      if (countdownTimer) {
        clearInterval(countdownTimer);
        countdownTimer = null;
      }
    }

    function startCountdown() {
      countdownValue = 3;
      gameStatus = 'countdown';
      renderCountdown(countdownValue);

      countdownTimer = setInterval(() => {
        countdownValue--;
        if (countdownValue <= 0) {
          clearInterval(countdownTimer);
          countdownTimer = null;
          gameStatus = 'playing';
          gameRunning = true;
          launchBall();
          lastTimestamp = 0;
          accumulator = 0;
          animFrameId = requestAnimationFrame(gameLoop);
        } else {
          renderCountdown(countdownValue);
        }
      }, 1000);
    }

    function launchBall() {
      const angle = (Math.random() - 0.5) * Math.PI / 3;
      const dir = Math.random() > 0.5 ? 1 : -1;
      PongSim.launchBall(simState, angle, dir);
    }

    function gameOver(playerWon) {
      gameStatus = 'finished';
      gameRunning = false;
      if (animFrameId) {
        cancelAnimationFrame(animFrameId);
        animFrameId = null;
      }

      const titleEl = document.getElementById('gameover-title');
      const scoreEl = document.getElementById('gameover-score');

      if (playerWon) {
        titleEl.textContent = 'You Win!';
        titleEl.className = 'text-3xl font-bold mb-3 text-green-400';
      } else {
        titleEl.textContent = 'You Lose';
        titleEl.className = 'text-3xl font-bold mb-3 text-red-400';
      }

      scoreEl.textContent = 'Final Score: ' + score.player + ' - ' + score.bot;
      showView('view-gameover');
    }

    // =============================================
    // INPUT HANDLING
    // =============================================
    let inputSetup = false;

    function setupInput() {
      if (inputSetup) return;
      inputSetup = true;

      document.addEventListener('keydown', (e) => {
        if (['w', 'W', 's', 'S', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
          e.preventDefault();
        }
        keys[e.key] = true;
        updatePlayerInput();
      });

      document.addEventListener('keyup', (e) => {
        keys[e.key] = false;
        updatePlayerInput();
      });
    }

    function updatePlayerInput() {
      if (keys['w'] || keys['W'] || keys['ArrowUp']) {
        playerInput = 'up';
      } else if (keys['s'] || keys['S'] || keys['ArrowDown']) {
        playerInput = 'down';
      } else {
        playerInput = 'stop';
      }
    }

    // =============================================
    // PHYSICS (fixed timestep via PongSim)
    // =============================================
    function gameLoop(timestamp) {
      if (!gameRunning) return;

      if (lastTimestamp === 0) {
        lastTimestamp = timestamp;
        animFrameId = requestAnimationFrame(gameLoop);
        return;
      }

      let delta = timestamp - lastTimestamp;
      lastTimestamp = timestamp;

      // Clamp delta to prevent spiral of death
      if (delta > 200) delta = 200;

      accumulator += delta;

      while (accumulator >= PHYSICS_DT) {
        physicsTick();
        accumulator -= PHYSICS_DT;
      }

      render();
      animFrameId = requestAnimationFrame(gameLoop);
    }

    function physicsTick() {
      if (gameStatus !== 'playing') return;

      // --- Move player paddle via PongSim ---
      PongSim.applyInput(simState, 1, playerInput);

      // --- Move bot paddle (variable speed, directly sets y) ---
      updateBot();

      // --- Score pause countdown ---
      if (simState.pauseTicks > 0) {
        const pauseEnded = PongSim.tickPause(simState);
        isPaused = simState.paused;
        if (pauseEnded) {
          launchBall();
        }
        return;
      }

      // --- Step ball via PongSim ---
      const result = PongSim.stepBall(simState);

      // Play sound
      if (result.sound) {
        playPracticeSound(result.sound);
      }

      // --- Handle scoring ---
      if (result.scored) {
        if (result.scored === 2) {
          // Player 2 (bot) scored — ball went past player
          score.bot++;
          updateScoreDisplay();
          if (score.bot >= WIN_SCORE) { gameOver(false); return; }
        } else {
          // Player 1 scored — ball went past bot
          score.player++;
          updateScoreDisplay();
          if (score.player >= WIN_SCORE) { gameOver(true); return; }
        }
        PongSim.resetBallAfterScore(simState);
        isPaused = simState.paused;
      }
    }

    // =============================================
    // BOT AI (not in PongSim — needs variable speed)
    // =============================================
    function updateBot() {
      const now = performance.now();
      const config = getBotConfig();

      // Reaction delay: only update target every N ms
      if (now - botLastUpdateTime < config.reactionDelay) {
        moveBotToward(config);
        return;
      }
      botLastUpdateTime = now;

      // Decide if bot intentionally misses (easy only)
      if (config.mistakeChance > 0 && Math.random() < config.mistakeChance) {
        botIntentionalMiss = true;
      } else {
        botIntentionalMiss = false;
      }

      // Compute target y based on difficulty
      if (botIntentionalMiss) {
        botTargetY = Math.random() * (CANVAS_H - PADDLE_H);
      } else if (currentDifficulty === 'easy') {
        const jitter = (Math.random() - 0.5) * 80;
        botTargetY = simState.ball.y + BALL_SIZE / 2 - PADDLE_H / 2 + jitter;
      } else if (currentDifficulty === 'medium') {
        botTargetY = predictBallY(false) - PADDLE_H / 2;
      } else {
        botTargetY = predictBallY(true) - PADDLE_H / 2;
      }

      botTargetY = Math.max(0, Math.min(CANVAS_H - PADDLE_H, botTargetY));
      moveBotToward(config);
    }

    function moveBotToward(config) {
      const diff = botTargetY - simState.paddle2.y;
      const maxMove = PADDLE_SPEED * config.speedFactor;

      if (Math.abs(diff) < 2) return;

      if (diff < 0) {
        simState.paddle2.y = Math.max(0, simState.paddle2.y - Math.min(maxMove, Math.abs(diff)));
      } else {
        simState.paddle2.y = Math.min(CANVAS_H - PADDLE_H, simState.paddle2.y + Math.min(maxMove, diff));
      }
    }

    function getBotConfig() {
      switch (currentDifficulty) {
        case 'easy':
          return { reactionDelay: 200, speedFactor: 0.4, mistakeChance: 0.15 };
        case 'medium':
          return { reactionDelay: 100, speedFactor: 0.7, mistakeChance: 0 };
        case 'hard':
          return { reactionDelay: 50, speedFactor: 0.95, mistakeChance: 0 };
        default:
          return { reactionDelay: 100, speedFactor: 0.5, mistakeChance: 0 };
      }
    }

    function predictBallY(simulateBounces) {
      const ball = simState.ball;

      // If ball not moving toward bot, just track ball center
      if (ball.vx <= 0) {
        return ball.y + BALL_SIZE / 2;
      }

      if (!simulateBounces) {
        const targetX = P2_X;
        const timeToReach = (targetX - (ball.x + BALL_SIZE)) / ball.vx;
        if (timeToReach < 0) return ball.y + BALL_SIZE / 2;
        let predictedY = ball.y + ball.vy * timeToReach + BALL_SIZE / 2;
        predictedY = Math.max(BALL_SIZE, Math.min(CANVAS_H - BALL_SIZE, predictedY));
        return predictedY;
      }

      // Full trajectory simulation with bounces
      let simX = ball.x;
      let simY = ball.y;
      let simVx = ball.vx;
      let simVy = ball.vy;
      const maxSteps = 600;

      for (let i = 0; i < maxSteps; i++) {
        simX += simVx;
        simY += simVy;

        if (simY <= 0) {
          simVy = Math.abs(simVy);
          simY = 0;
        }
        if (simY >= CANVAS_H - BALL_SIZE) {
          simVy = -Math.abs(simVy);
          simY = CANVAS_H - BALL_SIZE;
        }

        if (simX + BALL_SIZE >= P2_X) {
          return simY + BALL_SIZE / 2;
        }

        if (simVx <= 0) {
          return ball.y + BALL_SIZE / 2;
        }
      }

      return ball.y + BALL_SIZE / 2;
    }

    // =============================================
    // RENDERING
    // =============================================
    function render() {
      if (!ctx || !simState) return;

      // Background
      ctx.fillStyle = '#0f0f2a';
      ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

      // Center dashed line
      ctx.setLineDash([8, 8]);
      ctx.strokeStyle = '#2d2d5e';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(CANVAS_W / 2, 0);
      ctx.lineTo(CANVAS_W / 2, CANVAS_H);
      ctx.stroke();
      ctx.setLineDash([]);

      // Large translucent score behind gameplay
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.font = 'bold 140px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(score.player, CANVAS_W / 4, CANVAS_H / 2 + 50);
      ctx.fillText(score.bot, (CANVAS_W * 3) / 4, CANVAS_H / 2 + 50);

      // Left paddle (player) - purple with glow
      drawPaddle(P1_X, simState.paddle1.y, true);

      // Right paddle (bot) - gray
      drawPaddle(P2_X, simState.paddle2.y, false);

      // Ball
      const bcx = simState.ball.x + BALL_SIZE / 2;
      const bcy = simState.ball.y + BALL_SIZE / 2;
      ctx.fillStyle = 'rgba(168, 85, 247, 0.15)';
      ctx.beginPath();
      ctx.arc(bcx, bcy, BALL_SIZE, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur = 18;
      ctx.beginPath();
      ctx.arc(bcx, bcy, BALL_SIZE / 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Pause overlay
      if (isPaused) {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
        ctx.fillStyle = '#a855f7';
        ctx.font = 'bold 32px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Get Ready...', CANVAS_W / 2, CANVAS_H / 2 + 12);
      }
    }

    function drawPaddle(x, y, isPlayer) {
      const skin = isPlayer ? playerSkin : null;
      const skinImage = isPlayer ? playerSkinImage : null;
      const isRightSide = !isPlayer;

      let paddleColor;
      if (skin && skin.type === 'color' && skin.cssValue) {
        paddleColor = skin.cssValue;
      } else if (isPlayer) {
        paddleColor = '#a855f7';
      } else {
        paddleColor = '#6b7280';
      }

      if (skin && skin.type === 'image' && skinImage) {
        const centerX = x + PADDLE_W / 2;
        const centerY = y + PADDLE_H / 2;
        const drawX = centerX - SKIN_DRAW_W / 2;
        const drawY = centerY - SKIN_DRAW_H / 2;

        ctx.save();
        if (isRightSide) {
          ctx.translate(centerX * 2, 0);
          ctx.scale(-1, 1);
          ctx.drawImage(skinImage, drawX, drawY, SKIN_DRAW_W, SKIN_DRAW_H);
        } else {
          ctx.drawImage(skinImage, drawX, drawY, SKIN_DRAW_W, SKIN_DRAW_H);
        }
        ctx.restore();
        return;
      }

      ctx.fillStyle = paddleColor;
      ctx.shadowColor = isPlayer ? paddleColor : 'transparent';
      ctx.shadowBlur = isPlayer ? 18 : 0;

      const r = 6;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + PADDLE_W - r, y);
      ctx.quadraticCurveTo(x + PADDLE_W, y, x + PADDLE_W, y + r);
      ctx.lineTo(x + PADDLE_W, y + PADDLE_H - r);
      ctx.quadraticCurveTo(x + PADDLE_W, y + PADDLE_H, x + PADDLE_W - r, y + PADDLE_H);
      ctx.lineTo(x + r, y + PADDLE_H);
      ctx.quadraticCurveTo(x, y + PADDLE_H, x, y + PADDLE_H - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function renderCountdown(seconds) {
      if (!ctx) return;
      ctx.fillStyle = '#0f0f2a';
      ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
      ctx.fillStyle = '#a855f7';
      ctx.font = 'bold 120px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(seconds, CANVAS_W / 2, CANVAS_H / 2 + 40);
      ctx.fillStyle = '#888';
      ctx.font = '24px sans-serif';
      ctx.fillText('Get Ready!', CANVAS_W / 2, CANVAS_H / 2 + 90);
    }

    function updateScoreDisplay() {
      document.getElementById('score-player').textContent = score.player;
      document.getElementById('score-bot').textContent = score.bot;
    }

  })();
  </script>
</body>
</html>
