<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CryptoPong — Practice Mode</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            arena: { bg: '#0a0a1a', card: '#111128', accent: '#7c3aed', glow: '#a855f7' }
          }
        }
      }
    };
  </script>
  <style>
    body { background: #0a0a1a; font-family: 'Segoe UI', system-ui, sans-serif; }
    .glow-border { box-shadow: 0 0 15px rgba(168, 85, 247, 0.3); }
    #game-canvas { background: #0f0f2a; border: 1px solid #2d2d5e; border-radius: 8px; }
    @keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 10px rgba(168, 85, 247, 0.4); } 50% { box-shadow: 0 0 25px rgba(168, 85, 247, 0.8); } }
    .diff-btn:hover { transform: translateY(-2px); transition: transform 0.2s; }
    .diff-btn.selected { ring: 2; }
  </style>
</head>
<body class="text-gray-100 min-h-screen">

  <!-- NAV BAR -->
  <nav class="bg-arena-card border-b border-purple-900/30 px-6 py-3 flex items-center justify-between">
    <div class="flex items-center gap-3">
      <a href="/" class="text-2xl font-bold bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent">CRYPTOPONG</a>
      <span class="text-xs text-gray-500 bg-gray-800 px-2 py-0.5 rounded">PRACTICE</span>
    </div>
    <a href="/" class="text-sm text-gray-400 hover:text-white transition">Back to CryptoPong</a>
  </nav>

  <!-- MAIN CONTENT -->
  <div class="max-w-5xl mx-auto px-4 py-6">

    <!-- Difficulty Selection Screen -->
    <div id="view-difficulty" class="text-center py-10">
      <h1 class="text-3xl font-bold mb-2 bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent">
        Practice Mode
      </h1>
      <p class="text-gray-400 mb-8 max-w-md mx-auto">
        Sharpen your skills against a bot. No wallet or stakes required.
      </p>
      <h2 class="text-xl font-bold mb-4">Choose Bot Difficulty</h2>
      <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 max-w-2xl mx-auto mb-6">
        <button onclick="selectDifficulty('easy')"
          class="diff-btn bg-arena-card border border-green-800 hover:border-green-500 rounded-xl p-6 text-center transition">
          <div class="text-green-400 text-2xl font-bold mb-1">Easy</div>
          <div class="text-gray-400 text-sm">Slow reactions, makes mistakes.</div>
          <div class="text-gray-500 text-xs mt-2">Great for beginners</div>
        </button>
        <button onclick="selectDifficulty('medium')"
          class="diff-btn bg-arena-card border border-yellow-800 hover:border-yellow-500 rounded-xl p-6 text-center transition">
          <div class="text-yellow-400 text-2xl font-bold mb-1">Medium</div>
          <div class="text-gray-400 text-sm">Predicts ball trajectory.</div>
          <div class="text-gray-500 text-xs mt-2">A solid challenge</div>
        </button>
        <button onclick="selectDifficulty('hard')"
          class="diff-btn bg-arena-card border border-red-800 hover:border-red-500 rounded-xl p-6 text-center transition">
          <div class="text-red-400 text-2xl font-bold mb-1">Hard</div>
          <div class="text-gray-400 text-sm">Full prediction, almost never misses.</div>
          <div class="text-gray-500 text-xs mt-2">Only for the brave</div>
        </button>
      </div>
      <p class="text-gray-600 text-xs">Controls: W/S or Arrow Up/Down. First to 5 wins.</p>
    </div>

    <!-- Game View -->
    <div id="view-game" class="hidden">
      <div class="flex justify-between items-center mb-2 px-2">
        <div class="text-sm"><span class="text-purple-400 font-bold">You</span> (Player)</div>
        <div class="text-2xl font-bold">
          <span id="score-player">0</span> - <span id="score-bot">0</span>
        </div>
        <div class="text-sm"><span id="bot-difficulty-label" class="text-gray-400 font-bold"></span> (Bot)</div>
      </div>
      <canvas id="game-canvas" width="800" height="600" class="mx-auto block"></canvas>
      <p class="text-center text-gray-500 text-xs mt-2">Controls: W/S or Arrow Keys | First to 5 wins</p>
    </div>

    <!-- Game Over Screen -->
    <div id="view-gameover" class="hidden text-center py-10">
      <div class="bg-arena-card rounded-xl px-8 py-8 max-w-md mx-auto glow-border">
        <h3 id="gameover-title" class="text-3xl font-bold mb-3"></h3>
        <p id="gameover-score" class="text-gray-400 text-lg mb-6"></p>
        <div class="flex flex-col sm:flex-row gap-3 justify-center">
          <button onclick="playAgain()"
            class="bg-purple-600 hover:bg-purple-700 px-6 py-2 rounded-lg font-medium transition">
            Play Again
          </button>
          <button onclick="changeDifficulty()"
            class="bg-gray-700 hover:bg-gray-600 px-6 py-2 rounded-lg font-medium transition">
            Change Difficulty
          </button>
        </div>
        <a href="/" class="inline-block mt-4 text-sm text-gray-400 hover:text-white transition">Back to CryptoPong</a>
      </div>
    </div>

  </div>

  <!-- ============ INLINE GAME SCRIPT ============ -->
  <script>
  (function() {
    'use strict';

    // =============================================
    // CONSTANTS — must match server PongEngine.js
    // =============================================
    const CANVAS_W = 800;
    const CANVAS_H = 600;
    const PADDLE_W = 26;
    const PADDLE_H = 110;
    const PADDLE_SPEED = 6;
    const BALL_SIZE = 16;
    const BALL_SPEED_INITIAL = 6;
    const BALL_SPEED_INCREMENT = 0.25;
    const BALL_MAX_SPEED = 14;
    const WIN_SCORE = 5;
    const SCORE_PAUSE_TICKS = 90; // 1.5s at 60 ticks/sec

    const PHYSICS_DT = 1000 / 60; // fixed timestep: 60 steps/sec

    // --- Sound Effects ---
    let practiceAudioCtx = null;
    function getPracticeAudio() {
      if (!practiceAudioCtx) practiceAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return practiceAudioCtx;
    }
    function playPracticeSound(type) {
      try {
        const ctx = getPracticeAudio();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        if (type === 'paddle') {
          osc.frequency.value = 440; osc.type = 'square';
          gain.gain.value = 0.1;
          gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);
          osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.08);
        } else if (type === 'wall') {
          osc.frequency.value = 300; osc.type = 'triangle';
          gain.gain.value = 0.06;
          gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.06);
          osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.06);
        } else if (type === 'score') {
          osc.frequency.value = 220; osc.type = 'sawtooth';
          gain.gain.value = 0.12;
          gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
          osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.3);
        }
      } catch (e) {}
    }

    // Paddle x positions
    const P1_X = 10;
    const P2_X = CANVAS_W - 10 - PADDLE_W;

    // =============================================
    // STATE
    // =============================================
    let canvas, ctx;
    let currentDifficulty = null;
    let gameRunning = false;
    let animFrameId = null;
    let lastTimestamp = 0;
    let accumulator = 0;

    // Game state
    let ball = { x: 0, y: 0, vx: 0, vy: 0 };
    let playerPaddle = { y: 0 };
    let botPaddle = { y: 0 };
    let score = { player: 0, bot: 0 };
    let pauseTicks = 0;
    let isPaused = false;
    let gameStatus = 'idle'; // 'idle', 'countdown', 'playing', 'finished'
    let countdownValue = 3;
    let countdownTimer = null;

    // Input
    const keys = {};
    let playerInput = 'stop';

    // Skin support
    const SKIN_DRAW_W = 60;
    const SKIN_DRAW_H = 200;
    let playerSkin = null;      // { type, cssValue, imageUrl }
    let playerSkinImage = null;  // preloaded Image for image-type skins

    // Bot AI state
    let botTargetY = CANVAS_H / 2;
    let botLastUpdateTime = 0;
    let botIntentionalMiss = false;

    // =============================================
    // LOAD EQUIPPED SKIN (if logged in)
    // =============================================
    (async function loadEquippedSkin() {
      try {
        const session = JSON.parse(localStorage.getItem('pong_session') || 'null');
        if (!session || !session.token) return;
        const res = await fetch('/api/profile', {
          headers: { 'Authorization': 'Bearer ' + session.token }
        });
        if (!res.ok) return;
        const data = await res.json();
        const equippedId = data.user && data.user.equippedSkin;
        if (!equippedId || equippedId === 'default') return;
        // Fetch shop to find skin details
        const shopRes = await fetch('/api/shop', {
          headers: { 'Authorization': 'Bearer ' + session.token }
        });
        if (!shopRes.ok) return;
        const shopData = await shopRes.json();
        // Search inventory for the equipped skin
        const skin = (shopData.inventory || []).find(s => s.skinId === equippedId);
        if (!skin) return;
        playerSkin = skin;
        if (skin.type === 'image' && skin.imageUrl) {
          const img = new Image();
          img.src = skin.imageUrl;
          img.onload = () => { playerSkinImage = img; };
        }
      } catch (e) {
        // Silent fail — just use default purple
      }
    })();

    // =============================================
    // VIEW MANAGEMENT
    // =============================================
    function showView(viewId) {
      document.getElementById('view-difficulty').classList.add('hidden');
      document.getElementById('view-game').classList.add('hidden');
      document.getElementById('view-gameover').classList.add('hidden');
      document.getElementById(viewId).classList.remove('hidden');
    }

    // =============================================
    // DIFFICULTY SELECTION
    // =============================================
    window.selectDifficulty = function(diff) {
      currentDifficulty = diff;
      const labels = { easy: 'Easy', medium: 'Medium', hard: 'Hard' };
      document.getElementById('bot-difficulty-label').textContent = labels[diff];
      showView('view-game');
      startGame();
    };

    window.playAgain = function() {
      showView('view-game');
      startGame();
    };

    window.changeDifficulty = function() {
      stopGame();
      showView('view-difficulty');
    };

    // =============================================
    // GAME LIFECYCLE
    // =============================================
    function startGame() {
      canvas = document.getElementById('game-canvas');
      ctx = canvas.getContext('2d');

      // Reset state
      score = { player: 0, bot: 0 };
      playerPaddle = { y: CANVAS_H / 2 - PADDLE_H / 2 };
      botPaddle = { y: CANVAS_H / 2 - PADDLE_H / 2 };
      ball = { x: CANVAS_W / 2 - BALL_SIZE / 2, y: CANVAS_H / 2 - BALL_SIZE / 2, vx: 0, vy: 0 };
      pauseTicks = 0;
      isPaused = false;
      gameStatus = 'countdown';
      countdownValue = 3;
      accumulator = 0;
      lastTimestamp = 0;
      botTargetY = CANVAS_H / 2;
      botLastUpdateTime = 0;
      botIntentionalMiss = false;

      updateScoreDisplay();
      setupInput();
      startCountdown();
    }

    function stopGame() {
      gameRunning = false;
      gameStatus = 'idle';
      if (animFrameId) {
        cancelAnimationFrame(animFrameId);
        animFrameId = null;
      }
      if (countdownTimer) {
        clearInterval(countdownTimer);
        countdownTimer = null;
      }
    }

    function startCountdown() {
      countdownValue = 3;
      gameStatus = 'countdown';
      renderCountdown(countdownValue);

      countdownTimer = setInterval(() => {
        countdownValue--;
        if (countdownValue <= 0) {
          clearInterval(countdownTimer);
          countdownTimer = null;
          gameStatus = 'playing';
          gameRunning = true;
          launchBall();
          lastTimestamp = 0;
          accumulator = 0;
          animFrameId = requestAnimationFrame(gameLoop);
        } else {
          renderCountdown(countdownValue);
        }
      }, 1000);
    }

    function gameOver(playerWon) {
      gameStatus = 'finished';
      gameRunning = false;
      if (animFrameId) {
        cancelAnimationFrame(animFrameId);
        animFrameId = null;
      }

      const titleEl = document.getElementById('gameover-title');
      const scoreEl = document.getElementById('gameover-score');

      if (playerWon) {
        titleEl.textContent = 'You Win!';
        titleEl.className = 'text-3xl font-bold mb-3 text-green-400';
      } else {
        titleEl.textContent = 'You Lose';
        titleEl.className = 'text-3xl font-bold mb-3 text-red-400';
      }

      scoreEl.textContent = 'Final Score: ' + score.player + ' - ' + score.bot;
      showView('view-gameover');
    }

    // =============================================
    // INPUT HANDLING
    // =============================================
    let inputSetup = false;

    function setupInput() {
      if (inputSetup) return;
      inputSetup = true;

      document.addEventListener('keydown', (e) => {
        if (['w', 'W', 's', 'S', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
          e.preventDefault();
        }
        keys[e.key] = true;
        updatePlayerInput();
      });

      document.addEventListener('keyup', (e) => {
        keys[e.key] = false;
        updatePlayerInput();
      });
    }

    function updatePlayerInput() {
      if (keys['w'] || keys['W'] || keys['ArrowUp']) {
        playerInput = 'up';
      } else if (keys['s'] || keys['S'] || keys['ArrowDown']) {
        playerInput = 'down';
      } else {
        playerInput = 'stop';
      }
    }

    // =============================================
    // PHYSICS (fixed timestep)
    // =============================================
    function gameLoop(timestamp) {
      if (!gameRunning) return;

      if (lastTimestamp === 0) {
        lastTimestamp = timestamp;
        animFrameId = requestAnimationFrame(gameLoop);
        return;
      }

      let delta = timestamp - lastTimestamp;
      lastTimestamp = timestamp;

      // Clamp delta to prevent spiral of death
      if (delta > 200) delta = 200;

      accumulator += delta;

      while (accumulator >= PHYSICS_DT) {
        physicsTick();
        accumulator -= PHYSICS_DT;
      }

      render();
      animFrameId = requestAnimationFrame(gameLoop);
    }

    function physicsTick() {
      if (gameStatus !== 'playing') return;

      // --- Move player paddle ---
      if (playerInput === 'up') {
        playerPaddle.y = Math.max(0, playerPaddle.y - PADDLE_SPEED);
      } else if (playerInput === 'down') {
        playerPaddle.y = Math.min(CANVAS_H - PADDLE_H, playerPaddle.y + PADDLE_SPEED);
      }

      // --- Move bot paddle ---
      updateBot();

      // --- Score pause countdown ---
      if (pauseTicks > 0) {
        pauseTicks--;
        isPaused = true;
        if (pauseTicks === 0) {
          isPaused = false;
          launchBall();
        }
        return;
      }

      // --- Move ball (with swept collision) ---
      moveBallWithSweptCollision();
    }

    // =============================================
    // BALL PHYSICS — SUB-STEP SWEPT COLLISION
    // =============================================
    function moveBallWithSweptCollision() {
      const p1Right = P1_X + PADDLE_W;
      const p2Left = P2_X;
      const p2Right = P2_X + PADDLE_W;

      // Break movement into sub-steps to prevent pass-through at any speed
      const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
      const steps = Math.max(1, Math.ceil(speed / (PADDLE_W / 2)));
      const stepVx = ball.vx / steps;
      const stepVy = ball.vy / steps;

      for (let s = 0; s < steps; s++) {
        const oldX = ball.x;
        const oldY = ball.y;

        ball.x += stepVx;
        ball.y += stepVy;

        // --- Top/bottom wall bounce ---
        if (ball.y <= 0) {
          ball.vy = Math.abs(ball.vy);
          ball.y = -ball.y;
          playPracticeSound('wall');
        }
        if (ball.y >= CANVAS_H - BALL_SIZE) {
          ball.vy = -Math.abs(ball.vy);
          ball.y = 2 * (CANVAS_H - BALL_SIZE) - ball.y;
          playPracticeSound('wall');
        }

        // --- Left paddle (player) collision ---
        if (ball.vx < 0) {
          // Swept: ball left edge crossed paddle right edge
          if (oldX >= p1Right && ball.x < p1Right) {
            const t = (oldX - p1Right) / (oldX - ball.x);
            const hitY = oldY + (ball.y - oldY) * t;
            if (hitY + BALL_SIZE >= playerPaddle.y && hitY <= playerPaddle.y + PADDLE_H) {
              const spd = Math.min(Math.abs(ball.vx) + BALL_SPEED_INCREMENT, BALL_MAX_SPEED);
              ball.vx = spd;
              ball.x = p1Right;
              ball.y = hitY;
              const hitPos = (ball.y + BALL_SIZE / 2 - playerPaddle.y) / PADDLE_H;
              ball.vy = (hitPos - 0.5) * spd * 1.5;
              playPracticeSound('paddle');
              return;
            }
          }
          // Overlap fallback
          if (ball.x < p1Right && ball.x + BALL_SIZE > P1_X &&
              ball.y + BALL_SIZE > playerPaddle.y && ball.y < playerPaddle.y + PADDLE_H) {
            const spd = Math.min(Math.abs(ball.vx) + BALL_SPEED_INCREMENT, BALL_MAX_SPEED);
            ball.vx = spd;
            ball.x = p1Right;
            const hitPos = (ball.y + BALL_SIZE / 2 - playerPaddle.y) / PADDLE_H;
            ball.vy = (hitPos - 0.5) * spd * 1.5;
            playPracticeSound('paddle');
            return;
          }
        }

        // --- Right paddle (bot) collision ---
        if (ball.vx > 0) {
          const oldRight = oldX + BALL_SIZE;
          const newRight = ball.x + BALL_SIZE;
          // Swept: ball right edge crossed paddle left edge
          if (oldRight <= p2Left && newRight > p2Left) {
            const t = (p2Left - oldRight) / (newRight - oldRight);
            const hitY = oldY + (ball.y - oldY) * t;
            if (hitY + BALL_SIZE >= botPaddle.y && hitY <= botPaddle.y + PADDLE_H) {
              const spd = Math.min(Math.abs(ball.vx) + BALL_SPEED_INCREMENT, BALL_MAX_SPEED);
              ball.vx = -spd;
              ball.x = p2Left - BALL_SIZE;
              ball.y = hitY;
              const hitPos = (ball.y + BALL_SIZE / 2 - botPaddle.y) / PADDLE_H;
              ball.vy = (hitPos - 0.5) * spd * 1.5;
              playPracticeSound('paddle');
              return;
            }
          }
          // Overlap fallback
          if (ball.x + BALL_SIZE > p2Left && ball.x < p2Right &&
              ball.y + BALL_SIZE > botPaddle.y && ball.y < botPaddle.y + PADDLE_H) {
            const spd = Math.min(Math.abs(ball.vx) + BALL_SPEED_INCREMENT, BALL_MAX_SPEED);
            ball.vx = -spd;
            ball.x = p2Left - BALL_SIZE;
            const hitPos = (ball.y + BALL_SIZE / 2 - botPaddle.y) / PADDLE_H;
            ball.vy = (hitPos - 0.5) * spd * 1.5;
            playPracticeSound('paddle');
            return;
          }
        }

        // --- Scoring ---
        if (ball.x + BALL_SIZE < 0) {
          score.bot++;
          updateScoreDisplay();
          playPracticeSound('score');
          if (score.bot >= WIN_SCORE) { gameOver(false); return; }
          resetBall();
          return;
        }
        if (ball.x > CANVAS_W) {
          score.player++;
          updateScoreDisplay();
          playPracticeSound('score');
          if (score.player >= WIN_SCORE) { gameOver(true); return; }
          resetBall();
          return;
        }
      }
    }

    function resetBall() {
      ball.x = CANVAS_W / 2 - BALL_SIZE / 2;
      ball.y = CANVAS_H / 2 - BALL_SIZE / 2;
      ball.vx = 0;
      ball.vy = 0;
      pauseTicks = SCORE_PAUSE_TICKS;
      isPaused = true;
    }

    function launchBall() {
      const angle = (Math.random() - 0.5) * Math.PI / 3; // -30 to +30 degrees
      const dir = Math.random() > 0.5 ? 1 : -1;
      ball.vx = Math.cos(angle) * BALL_SPEED_INITIAL * dir;
      ball.vy = Math.sin(angle) * BALL_SPEED_INITIAL;
    }

    // =============================================
    // BOT AI
    // =============================================
    function updateBot() {
      const now = performance.now();
      const config = getBotConfig();

      // Reaction delay: only update target every N ms
      if (now - botLastUpdateTime < config.reactionDelay) {
        // Move toward last known target
        moveBotToward(config);
        return;
      }
      botLastUpdateTime = now;

      // Decide if bot intentionally misses (easy only)
      if (config.mistakeChance > 0 && Math.random() < config.mistakeChance) {
        botIntentionalMiss = true;
      } else {
        botIntentionalMiss = false;
      }

      // Compute target y based on difficulty
      if (botIntentionalMiss) {
        // Move to a random wrong position
        botTargetY = Math.random() * (CANVAS_H - PADDLE_H);
      } else if (currentDifficulty === 'easy') {
        // Track ball center with jitter
        const jitter = (Math.random() - 0.5) * 80;
        botTargetY = ball.y + BALL_SIZE / 2 - PADDLE_H / 2 + jitter;
      } else if (currentDifficulty === 'medium') {
        // Predict where ball arrives at bot paddle x
        botTargetY = predictBallY(false) - PADDLE_H / 2;
      } else {
        // Hard: full trajectory prediction with bounces
        botTargetY = predictBallY(true) - PADDLE_H / 2;
      }

      // Clamp target
      botTargetY = Math.max(0, Math.min(CANVAS_H - PADDLE_H, botTargetY));

      moveBotToward(config);
    }

    function moveBotToward(config) {
      const diff = botTargetY - botPaddle.y;
      const maxMove = PADDLE_SPEED * config.speedFactor;

      if (Math.abs(diff) < 2) return; // close enough

      if (diff < 0) {
        botPaddle.y = Math.max(0, botPaddle.y - Math.min(maxMove, Math.abs(diff)));
      } else {
        botPaddle.y = Math.min(CANVAS_H - PADDLE_H, botPaddle.y + Math.min(maxMove, diff));
      }
    }

    function getBotConfig() {
      switch (currentDifficulty) {
        case 'easy':
          return { reactionDelay: 200, speedFactor: 0.4, mistakeChance: 0.15 };
        case 'medium':
          return { reactionDelay: 100, speedFactor: 0.7, mistakeChance: 0 };
        case 'hard':
          return { reactionDelay: 50, speedFactor: 0.95, mistakeChance: 0 };
        default:
          return { reactionDelay: 100, speedFactor: 0.5, mistakeChance: 0 };
      }
    }

    function predictBallY(simulateBounces) {
      // If ball not moving toward bot, just track ball center
      if (ball.vx <= 0) {
        return ball.y + BALL_SIZE / 2;
      }

      if (!simulateBounces) {
        // Simple linear prediction: where does ball intersect bot paddle x?
        const targetX = P2_X;
        const timeToReach = (targetX - (ball.x + BALL_SIZE)) / ball.vx;
        if (timeToReach < 0) return ball.y + BALL_SIZE / 2;
        let predictedY = ball.y + ball.vy * timeToReach + BALL_SIZE / 2;
        // Clamp loosely
        predictedY = Math.max(BALL_SIZE, Math.min(CANVAS_H - BALL_SIZE, predictedY));
        return predictedY;
      }

      // Full trajectory simulation with bounces
      let simX = ball.x;
      let simY = ball.y;
      let simVx = ball.vx;
      let simVy = ball.vy;
      const maxSteps = 600; // prevent infinite loops

      for (let i = 0; i < maxSteps; i++) {
        simX += simVx;
        simY += simVy;

        // Wall bounces
        if (simY <= 0) {
          simVy = Math.abs(simVy);
          simY = 0;
        }
        if (simY >= CANVAS_H - BALL_SIZE) {
          simVy = -Math.abs(simVy);
          simY = CANVAS_H - BALL_SIZE;
        }

        // Reached bot paddle x?
        if (simX + BALL_SIZE >= P2_X) {
          return simY + BALL_SIZE / 2;
        }

        // If ball started going left, it won't reach bot
        if (simVx <= 0) {
          return ball.y + BALL_SIZE / 2;
        }
      }

      return ball.y + BALL_SIZE / 2;
    }

    // =============================================
    // RENDERING
    // =============================================
    function render() {
      if (!ctx) return;

      // Background
      ctx.fillStyle = '#0f0f2a';
      ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

      // Center dashed line
      ctx.setLineDash([8, 8]);
      ctx.strokeStyle = '#2d2d5e';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(CANVAS_W / 2, 0);
      ctx.lineTo(CANVAS_W / 2, CANVAS_H);
      ctx.stroke();
      ctx.setLineDash([]);

      // Large translucent score behind gameplay
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.font = 'bold 140px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(score.player, CANVAS_W / 4, CANVAS_H / 2 + 50);
      ctx.fillText(score.bot, (CANVAS_W * 3) / 4, CANVAS_H / 2 + 50);

      // Left paddle (player) - purple with glow
      drawPaddle(P1_X, playerPaddle.y, true);

      // Right paddle (bot) - gray
      drawPaddle(P2_X, botPaddle.y, false);

      // Ball — larger, softer glow
      const bcx = ball.x + BALL_SIZE / 2;
      const bcy = ball.y + BALL_SIZE / 2;
      ctx.fillStyle = 'rgba(168, 85, 247, 0.15)';
      ctx.beginPath();
      ctx.arc(bcx, bcy, BALL_SIZE, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur = 18;
      ctx.beginPath();
      ctx.arc(bcx, bcy, BALL_SIZE / 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Pause overlay
      if (isPaused) {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
        ctx.fillStyle = '#a855f7';
        ctx.font = 'bold 32px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Get Ready...', CANVAS_W / 2, CANVAS_H / 2 + 12);
      }
    }

    function drawPaddle(x, y, isPlayer) {
      const skin = isPlayer ? playerSkin : null;
      const skinImage = isPlayer ? playerSkinImage : null;
      const isRightSide = !isPlayer; // bot is on the right

      // Determine paddle color
      let paddleColor;
      if (skin && skin.type === 'color' && skin.cssValue) {
        paddleColor = skin.cssValue;
      } else if (isPlayer) {
        paddleColor = '#a855f7';
      } else {
        paddleColor = '#6b7280';
      }

      // If image skin with loaded image, draw centered on paddle hitbox
      if (skin && skin.type === 'image' && skinImage) {
        const centerX = x + PADDLE_W / 2;
        const centerY = y + PADDLE_H / 2;
        const drawX = centerX - SKIN_DRAW_W / 2;
        const drawY = centerY - SKIN_DRAW_H / 2;

        ctx.save();
        if (isRightSide) {
          ctx.translate(centerX * 2, 0);
          ctx.scale(-1, 1);
          ctx.drawImage(skinImage, drawX, drawY, SKIN_DRAW_W, SKIN_DRAW_H);
        } else {
          ctx.drawImage(skinImage, drawX, drawY, SKIN_DRAW_W, SKIN_DRAW_H);
        }
        ctx.restore();
        return;
      }

      // Color skin or default — rounded rect with glow
      ctx.fillStyle = paddleColor;
      ctx.shadowColor = isPlayer ? paddleColor : 'transparent';
      ctx.shadowBlur = isPlayer ? 18 : 0;

      const r = 6;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + PADDLE_W - r, y);
      ctx.quadraticCurveTo(x + PADDLE_W, y, x + PADDLE_W, y + r);
      ctx.lineTo(x + PADDLE_W, y + PADDLE_H - r);
      ctx.quadraticCurveTo(x + PADDLE_W, y + PADDLE_H, x + PADDLE_W - r, y + PADDLE_H);
      ctx.lineTo(x + r, y + PADDLE_H);
      ctx.quadraticCurveTo(x, y + PADDLE_H, x, y + PADDLE_H - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function renderCountdown(seconds) {
      if (!ctx) return;
      ctx.fillStyle = '#0f0f2a';
      ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
      ctx.fillStyle = '#a855f7';
      ctx.font = 'bold 120px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(seconds, CANVAS_W / 2, CANVAS_H / 2 + 40);
      ctx.fillStyle = '#888';
      ctx.font = '24px sans-serif';
      ctx.fillText('Get Ready!', CANVAS_W / 2, CANVAS_H / 2 + 90);
    }

    function updateScoreDisplay() {
      document.getElementById('score-player').textContent = score.player;
      document.getElementById('score-bot').textContent = score.bot;
    }

  })();
  </script>
</body>
</html>
